## MiniLight

​	MiniLight是一个小型的全局光照渲染器。

### 描述

​	MiniLight是一个小型的全局光照渲染器。它是一个简单的实现，但这也让它在某种意义上成为了开发和实验的良好基准。它可能还是最简洁和整齐的渲染器（代码大概只有650行），并且被翻译成了好几种不同的编程语言。

​	有人问我如何在三个月内开发一款渲染器。这时间其实不太够，但让我开始思考一个程序能够保持完整的基于物理的模拟，并同时具有简洁、良好的设计时，到底能够有多小。这个想法让我忍俊不禁，并迫不及待地动手实践了起来。

​	MiniLight是一个命令行工具。它会读取一个文本文件作为模板并通过该模板生成一个PPM格式的图像文件。支持平台有**Mac，Linux，Windows**。

​	渲染特性有：

- 蒙特卡洛路线追踪运输
- 发射器采样
- 渐进式细化
- RGB灯光
- 漫射材料
- 三角建模函数
- 八叉树空间索引
- 针孔镜头
- 病房线性色调映射



### 图像



​	Cornell盒子在一天中的变化

:<img src="assets/1546934967416.png" />



​	这个模型也是有物理基础的。比如，在中午的时候：天空的色温为10000K，亮度为1×104cd / m2。太阳的色温为5400K，亮度为1×109cd / m2，直径为1.392×109米，距离为149.6×109米。



​	一些Smits测试场景：

​	![1546935216900](assets/1546935216900.png).

​	一个房子，在中午和晚上：

![1546935255395](assets/1546935255395.png).

​	所有的这些图片都是每像素渲染1000条路径。标准的Cornell盒，500 * 500像素，在2007年的机器上将花费大概15min的时间。

​	（一般来说，模板文件只是一个简单并独立的文本文件，但如果采用JSON格式的化，最好采用推荐的JSON格式）



### 比较



​	MiniLight有八种语言的版本：![1547033723602](assets/1547033723602.png)

​	上述行数不包括注释和空白行，同时只有单个大括号或括号的行也不被包括在内。

​	速度只是一个粗略的统计。

​	“路径”实际上也会在每个节点发送“阴影射线” 。因此，每秒路径的两倍会给出一般的每秒基本光线轨迹或交叉点 。

​	C比C++快可能是因为LLVM对C做了链接时的优化。

​	此外呢，Scala、Lua还有Python都比C慢了两倍，主要是因为内联了一些向量操作。



### 算法



#### 路径追踪

​	最简单的全局照明方法就是纯粹的**蒙特卡洛路径追踪**。对每个像素，都会发送一条光线到场景中。当光线碰到物体时会记录下它的颜色和发射，然后光线反射并继续。最终记录的所有消息都会一个接一个的返回。每一步都会通过一个特殊的因子来测量亮度直到一个最终的值被返回给像素。添加随机性后多次重复这个过程并平均所有结果。一幅图像就会慢慢的显现出来。

​	这个策略本质是对发光体的盲目搜寻。除非光线碰到发光体，不然只会返回黑暗。对于户外场景，大多数光线将会反射到天空，并找到亮度。但是对室内场景来说，发射器太小了，需要很多很多的光线才能找到它，这样太慢了。



#### 发射器采样

​	

